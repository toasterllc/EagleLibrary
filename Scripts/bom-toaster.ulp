#require 6.5100

string Version = "1.11";

char   Separator = ';'; // 2012-12-04

#usage "en: <b>Export a Bill Of Material</b>\n"
           "<p>"
           "Generates a project's <i>Bill Of Material</i>&nbsp;&nbsp;including the attributes introduced in"
           " version 5.0.0."
           "<p>"
           "<author>Author: support@cadsoft.de</author><br>"
           "<author>Modified to use the new attributes by Carsten Wille.</author><br>"
           "<author>.csv export added by Christian Schlittler.</author>"
           "<author>Select variant and switch on/off attributes alf@cadsoft.de</author>"

if (!schematic)
{
  dlgMessageBox (usage + "<hr><b>ERROR: No schematic!</b><p>\nThis program can only work in the schematic editor.");
  exit (1);
}

string SeparatorString;
int     NumParts;
numeric string Lines[];
numeric string PartName[];
string  PartValue[], PartDevice[], PartPackage[], PartHeadline[], PartNumber[];
numeric string PartDescription [];
int     PartValueOn[];
int     Selected;

string CurrentVariant = "";
string Variants[] = { "" };  // 2012-04-16
int    cntVD = 0;
int    VDsel = 0;


// cwi: Added arrays for an arbitraty number of attributes.
int FoundAttributes = 0;            // # of different attribute names found in schematic.
numeric string AttributesList[];    // Sorted list of all attributes found in the schematic.
numeric string PartAttributes[];    // Adjusted list of attributes per part.

enum { ltParts, ltValues };         // List Types
int ListType = 0;


string StripWhiteSpace (string s)
{
  while (s && isspace (s[0]))
    s = strsub (s, 1);
  while (s && isspace (s[strlen (s) - 1]))
    s = strsub (s, 0, strlen (s) - 1);
  return s;
}

string ReplaceTabs(string s)
{
  int i;
  while ((i = strchr(s, '\t')) >= 0)
        s = strsub(s, 0, i) + "\\t" + strsub(s, i + 1);
  return s;
}

// Collect part data from the schematic.
//
// Arguments: -
//
// Returns:   NumParts            - # of found parts
//            PartName[]
//            PartValue[]
//            PartDevice[]
//            PartPackage[]
//            PartHeadline[]
//            PartNumber[]
//            PartDescription []
//            PartValueOn[]      - 0=part value off, 1= part value on, 2=override with attr. VAL
//            FoundAttributes     - # of different attribute names found in schematic.
//            AttributesList[]   - Sorted list of all attributes found in the schematic.
//            PartAttributes[]   - Adjusted list of attributes per part.

void CollectPartData (string var)
{
  int Found = 0;
  int i;
  string attr[];

  NumParts = 0;

  // First, collect the names of all available attributes.
  FoundAttributes = 0;
  schematic (SCH)
  {
    SCH.allparts (P) // 2014-08-07
    {
      if (P.device.package)
      {
        if (P.populate)
        {
          P.attributes (A)
          {
            if (0 == FoundAttributes)
            {
              // First one
              AttributesList[0] = A.name;
              FoundAttributes = 1;
            }
            else
            {
              Found = 0;
              for (i = 0; i < FoundAttributes; i ++)
              {
                if (A.name == AttributesList[i])
                {
                  // Found an already listed atrribute
                  Found = 1;
                  break;
                }
              }
              if (0 == Found)
              {
                // Attribute not listed, add at the end.
                AttributesList[FoundAttributes] = A.name;
                FoundAttributes ++;
              }
            }
          }
        }
      }
    }
  }
  sort (FoundAttributes, AttributesList);
  // Second, collect all data
  schematic (SCH)
  {
    SCH.allparts (P)
    {
      if (P.device.package)
      {
        if (P.populate)
        {
          PartName[NumParts] = P.name;
          PartValue[NumParts] = P.value;
          PartDevice[NumParts] = P.device.name;
          PartPackage[NumParts] = P.device.package.name;
          PartHeadline[NumParts] = ReplaceTabs(P.device.headline);
          // currently not used:
          // PartDescription[NumParts] = ReplaceTabs(P.device.description);
          PartValueOn[NumParts] = P.device.value == "On";
          // Zero all strings
          for (i = 0; i < FoundAttributes; i ++)
            attr[i] = "";
          P.attributes(A)
          {
            for (i = 0; i < FoundAttributes; i ++)
              if (A.name == AttributesList[i])
              {
                attr[i] = A.value;
                break;
              }
              
              if (A.name == "PN")
              {
                PartNumber[NumParts] = A.value;
              }
              
            if ("VALUE" == A.name && 0 < strlen (A.value))
             // Override old fashioned value information!
            PartValueOn[NumParts] = 2;
          }
          PartAttributes[NumParts] = strjoin(attr, Separator);
          NumParts ++;
        }
      }
    }
  }
}

void GenerateList (void)
{
  int NumLines = 0;
  int Index [];
  string attr[], s;

  s = strjoin(AttributesList, '\t');

  Lines[NumLines ++] = "Quantity\tParts\t" + s;
  sort (NumParts, Index, PartNumber, PartName, PartAttributes);
  for (int n1 = 0, n2 = 0; ++ n2 <= NumParts; )
  {
    int i1 = Index [n1];
    strsplit (attr, PartAttributes[i1], Separator);
    s = strjoin(attr, '\t');
    if (n2 < NumParts)
    {
      int i2 = Index [n2]; // 2012-11-08
      if (PartNumber[i1] != "" && PartNumber[i2] != "" && PartNumber[i1] == PartNumber[i2])
        continue;
    }
    string Quantity;
    sprintf (Quantity, "%d", n2 - n1);
    Lines[NumLines] = Quantity + "\t";
    for (;;)
    {
      Lines[NumLines] += PartName[i1];
      if (++n1 < n2)
      {
        i1 = Index [n1];
        Lines[NumLines] += ", ";
      }
      else
        break;
    }
    // cwi: add extra information from attributes
    // 2010-04-17 cwi: Included description.
    Lines[NumLines] += "\t" + s;
    NumLines ++;
  }
  Lines[NumLines] = "";
}

string MakeList (void)
{
  string List;
  int numHeaders;

  for (int l = 0; Lines[l]; l ++)
  {
    string a [];
    int n = strsplit (a, Lines[l], '\t');
    if (l == 0)
      numHeaders = n;
    else
      n = numHeaders; // for the hidden key!
    for (int i = 0; i < n; i ++)
      List += "\"" + a[i] + "\"" + SeparatorString;
    List += "\n";
  }
  return List;
}

void SaveList (void)
{
  // 2008-11-24 cwi:
  // - Added new format extension .csv
  // - Changed from .bom to .txt for text format.
  string FileName;
  string FileExt = ".csv";

  schematic(SCH) FileName = filesetext (SCH.name, FileExt);
  FileName = dlgFileSave ("Save Bill Of Material", FileName);
  if (FileName)
  {
    string a [];
    if (!fileglob (a, FileName) || dlgMessageBox ("File '" + FileName +
        "' exists\n\nOverwrite?", "+&Overwrite", "-&Cancel") == 0)
    {
      output (FileName, "wt")
      {
        printf ("%s", MakeList ()); // using "%s" to avoid problems if list contains any '%'
      }
    }
  }
}


schematic(SCH) {
  sprintf(SeparatorString, "%c", Separator);
  CurrentVariant = variant();
  SCH.variantdefs(VD) {
    if (CurrentVariant == VD.name) VDsel = cntVD;
    sprintf(Variants[cntVD], "%s", VD.name);
    cntVD++;
  }
}

setvariant(CurrentVariant);
CollectPartData(CurrentVariant);
GenerateList();
SaveList();
